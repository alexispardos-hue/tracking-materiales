
<!DOCTYPE html>

<html>

<head>

    <meta charset="UTF-8">

    <title>Tracking Dinámico (G.A.B.I. System)</title>

    <style>

        /* Estilos base */

        body {

            font-family: Arial, sans-serif; 

            margin: 0;

            padding: 0;

            background-color: #f4f4f4;

            display: flex;

            flex-direction: column;

            min-height: 100vh;

        }

        header {

            background-color: #333;

            color: white;

            padding: 10px 20px;

            text-align: center;

        }

        /* Estilos para la Mejora 2: Panel lateral y Contenedor Principal */

        .main-container {

            display: flex;

            flex-grow: 1;

        }

        .controls-panel {

            width: 350px; /* Ancho fijo para el panel lateral */

            padding: 15px;

            background-color: #fff;

            box-shadow: 2px 0 5px rgba(0,0,0,0.1);

            display: flex;

            flex-direction: column;

        }

        /* Contenedor de Mapas (Horizontal) */

        .map-container-wrapper {

            flex-grow: 1;

            display: flex;

            flex-direction: column; /* Mapas apilados verticalmente */

            padding-left: 5px;

        }

        .map-view {

            flex: 1;

            height: 45vh; /* Mitad de la altura para cada mapa */

            margin-bottom: 10px;

            border: 1px solid #ccc;

        }



        #current-map-wrapper {

            position: relative;

            flex: 1;

        }

        #day-counter-overlay {

            position: absolute;

            top: 50%;

            left: 50%;

            transform: translate(-50%, -50%);

            z-index: 10;

            font-size: 2.5em; /* Número grande */

            font-weight: bold;

            color: #ff0000;

            background-color: rgba(255, 255, 255, 0.7);

            border: 3px solid #ff0000;

            padding: 10px 20px;

            border-radius: 8px;

            pointer-events: none;

            display: none;

            text-shadow: 1px 1px 2px white;

        }

            

        .search-container input[type="text"], 

        .search-container select {

            width: 100%;

            padding: 8px;

            margin-bottom: 10px;

            box-sizing: border-box;

            border: 1px solid #ccc;

            border-radius: 4px;

        }

        /* Estilos para el Contenedor de Ficha de Datos */

        #material-details {

            margin-top: 20px;

            padding: 15px;

            border: 1px solid #ddd;

            background-color: #f9f9f9;

            border-radius: 6px;

            font-size: 0.9em;

            flex-grow: 1;

            overflow-y: auto;

        }

        #material-details h4 {

            margin-top: 0;

            color: #1a73e8;

            border-bottom: 2px solid #eee;

            padding-bottom: 5px;

        }



        .detail-row strong {

            display: inline-block;

            width: 120px; /* Alineación de etiquetas */

            color: #555;

        }

        #results-list {

            list-style: none;

            padding: 0;

            margin: 0;

        }

        #results-list li {

            padding: 4px 0;

            border-bottom: 1px dotted #eee;

        }

    </style>

</head>

<body>



    <header>

        <h1>Sistema de Tracking de Materiales <small>(© aloris)</small></h1>

    </header>



    <div class="main-container">

        

        <div class="controls-panel">

            

            <div class="search-container">

                <label for="search-selector" style="font-weight: bold;">1. Seleccionar Campo de Búsqueda:</label>

                <select id="search-selector">

                    <option value="ID_MATERIAL">ID de Material</option>
                    <option value="DESCRIPCION">Descripción</option>
                    <option value="OC">Orden de Compra (OC)</option>
                    <option value="GUIA">Número de Guía</option>
                    <option value="PLANO_REF">Plano de Referencia</option>
                </select>

                

                <label for="search-input" style="font-weight: bold;">2. Escribir Término (Diccionario):</label>

                <input type="text" id="search-input" placeholder="Buscar..." oninput="filterDictionary(this.value)">

                

                <div id="dictionary-results" style="max-height: 200px; overflow-y: auto; border: 1px solid #ccc; padding: 5px; margin-top: 10px; display: none;">

                    <ul id="results-list"></ul>

                </div>

            </div>

            

            <hr style="width: 100%; border-top: 1px solid #eee;">

            

            <div id="status-message" style="margin-bottom: 15px;">Estado: Inicializando sistema...</div>

            

            <div id="material-details" style="display: none;">

                <h4>Ficha de Datos del Material Activo</h4>

            </div>



        </div>



        <div class="map-container-wrapper">

            <div id="current-map-wrapper">

                <div id="current-map" class="map-view"></div>

                <div id="day-counter-overlay"></div>

            </div>

            

            <div id="history-map" class="map-view"></div>

        </div>

        

    </div>



    

    <script>

        // *** 1. CONFIGURACIÓN CRÍTICA ***

        // ¡REEMPLAZAR ESTAS DOS VARIABLES!

        const API_KEY = 'AIzaSyApDMsqrpdpP3WvmyCx6056F79Iv6aXiTE'; 

        const ENDPOINT_URL = 'https://script.google.com/macros/s/AKfycbxNy9jTgU3LWha7a5h7o6xR30BM6_qXwvAT7Sb9NF_etE7VJ9ftF-IjAllWNoU_3Q9Y/exec'; 


        // Variables globales del estado del sistema



    

let map;
let historyMap; // Mapa de Tracking Histórico
let allMaterials = [];
let activeMaterial = null; // Objeto del material activo
let activeMarker = null; 
let activeMarkerId = null; // ID del material activo
let blinkInterval = null; 
let historyMarkers = []; 
let polyline = null; 
let initialLoad = true; 
const REFRESH_INTERVAL_MS = 10000; // Refresco cada 10 segundos

        // Carga la API de Google Maps de forma asíncrona

        function loadGoogleMapsScript() {

            const script = document.createElement('script');

            script.src = `https://maps.googleapis.com/maps/api/js?key=${API_KEY}&callback=initMap`;

            script.async = true;

            document.head.appendChild(script);

        }


        // 2. FUNCIÓN DE INICIALIZACIÓN DEL MAPA
        window.initMap = function() {
            // Coordenadas por defecto (Ej: Lima, Perú, para centralizar el inicio)
            const defaultLocation = { lat: -12.0464, lng: -77.0428 }; 
            map = new google.maps.Map(document.getElementById('current-map'), {
                zoom: 12,
                center: defaultLocation,
        
            });

            // 2. Mapa de Tracking Histórico (Contenedor: history-map)
            historyMap = new google.maps.Map(document.getElementById('history-map'), { // <--- CRÍTICO: Inicialización del mapa histórico

                zoom: 12,
                center: defaultLocation,


            });

            // Inicia la actualización periódica

            startDataRefresh();

            // Eliminado: document.getElementById('status-message').innerText = 'Estado: Sistema listo. Iniciando seguimiento periódico.';

        }


        // 3. FUNCIÓN PARA RECUPERAR DATOS DEL ENDPOINT (ROBUSTA)

        async function fetchMaterialData() {
            try {
             const response = await fetch(ENDPOINT_URL);
                const data = await response.json();                

                if (data.status === 'success') {
                    // FILTRADO ROBUSTO: Excluye cualquier objeto sin ID_MATERIAL (filas vacías/nulas)
                    allMaterials = data.data.filter(item => item && item.ID_MATERIAL); 

                       // CRÍTICO: ACTUALIZA EL ESTADO AQUÍ, SOLO DESPUÉS DE LA PRIMERA CARGA EXITOSA

                    if (initialLoad) {

                        document.getElementById('status-message').innerText = `Estado: Sistema listo. Total de materiales: ${allMaterials.length}`;

                        initialLoad = false;

                    } else {

                        document.getElementById('status-message').innerText = `Estado: Datos actualizados. Total de items: ${allMaterials.length}`;

                    }

                    // Si ya hay un material activo, actualiza solo ese marcador

                    if (activeMarkerId) {

                        updateActiveMarker(activeMarkerId);
                    }

                } else {

                    console.error("Error del Endpoint:", data.message);

                    document.getElementById('status-message').innerText = 'ERROR: No se pudieron obtener los datos.';

                }

            } catch (error) {

                console.error('Error de conexión con Apps Script:', error);

                document.getElementById('status-message').innerText = 'ERROR: Fallo en la conexión de red.';

            }

        }



        // 4. LÓGICA DE BÚSQUEDA POR ID (Usando la tecla ENTER)

        // Mantenida solo por compatibilidad, la búsqueda principal es ahora el diccionario.

        window.filterMaterial = function(event) {

            // Se activa solo al presionar ENTER

            if (event.key !== 'Enter') return; 



            const searchId = document.getElementById('search-input').value.trim().toUpperCase();

            

            if (!searchId) {

                clearActiveMarker();

                return;

            }

            updateActiveMarker(searchId);

        }


        // 5. FUNCIÓN CRÍTICA DE ACTUALIZACIÓN DE MARCADOR (CORREGIDA)

        function updateActiveMarker(searchId) {

            // Busca el material usando las claves limpias del Apps Script

            const material = allMaterials.find(item => item && item.ID_MATERIAL && item.ID_MATERIAL.toUpperCase() === searchId);


            // Limpia el marcador y el ID anterior antes de proceder (limpia el parpadeo)

            clearActiveMarker(); 

            document.getElementById('material-details').style.display = 'none'; // Oculta ficha anterior



            if (material && material.LATITUD && material.LONGITUD) {

                activeMarkerId = searchId; // Establece el ID activo

                

                const position = { 

                    lat: parseFloat(material.LATITUD), 

                    lng: parseFloat(material.LONGITUD) 

                };


                // -------------------------------------------------------------

                // ** GENERACIÓN DEL CONTENT STRING CON CELDAS AÑADIDAS **

                // -------------------------------------------------------------

                const contentString = `

                    <div style="font-family: Arial, sans-serif; max-width: 300px;">

                        <h4 style="margin-top: 0; color: #1a73e8;">Material: ${material.ID_MATERIAL}</h4>

                        <p><strong>Descripción:</strong> ${material.DESCRIPCION || 'N/A'}</p>

                        <p><strong>Estado:</strong> <span style="font-weight: bold; color: green;">${material.ESTADO || 'N/A'}</span></p>      

                        <hr style="border-top: 1px solid #eee; margin: 8px 0;">

                        

                        <p><strong>Cantidad:</strong> ${material.CANTIDAD || 'N/A'}</p>

                        <p><strong>OC:</strong> ${material.OC || 'N/A'}</p>

                        <p><strong>Guía:</strong> ${material.GUIA || 'N/A'}</p>

                        <p><strong>Plano Ref:</strong> ${material.PLANO_REF || 'N/A'}</p>

                        

                        <p style="font-size: 0.8em; color: #777;">Lat/Lng: ${position.lat.toFixed(4)}, ${position.lng.toFixed(4)}</p>

                    </div>`;





                // Crea el nuevo marcador 

                activeMarker = new google.maps.Marker({

                    position: position,

                    map: map,

                    title: material.ID_MATERIAL,

                    icon: {

                        path: google.maps.SymbolPath.CIRCLE,

                        scale: 10,

                        fillColor: '#FF0000',

                        fillOpacity: 0.9,

                        strokeWeight: 0,

                    }

                });



                // *** INICIA EL EFECTO DE PARPADEO (3 segundos) ***

                startBlinking(activeMarker, 3000); 

                

                // Centra el mapa en la nueva posición y establece un zoom adecuado

                map.setCenter(position);

                map.setZoom(15); 

                

                // Añade la información en un infowindow

                const infoWindow = new google.maps.InfoWindow({

                    content: contentString

                });



                activeMarker.addListener('click', () => {

                    infoWindow.open(map, activeMarker);

                });



                // CRÍTICO: Llamada para mostrar la ficha de datos

                displayMaterialDetails(searchId); 

                

                // CRÍTICO: Llamada para actualizar el contador de días

                updateDayCounter(material.FECHA_ACTUALIZACION, position);



                // Asumiendo que el material tiene un historial (HISTORY)

                if (material.HISTORY && material.HISTORY.length > 0) {

                    plotHistoricalTracking(material.HISTORY, material.ID_MATERIAL);

                } else {

                    clearHistoryTracking();

                }



                document.getElementById('status-message').innerText = `Estado: Material ${searchId} ubicado y en seguimiento activo.`;



            } else {

                document.getElementById('status-message').innerText = `Advertencia: Material ${searchId} no encontrado o sin coordenadas válidas.`;

            }

        }





        // 6. FUNCIÓN PARA INICIAR EL PARPADEO (3 segundos por ciclo)

        function startBlinking(marker, interval) {

            if (blinkInterval) {

                clearInterval(blinkInterval);

            }

            

            let isVisible = true;

            

            blinkInterval = setInterval(() => {

                const icon = marker.getIcon();

                icon.fillOpacity = isVisible ? 0.2 : 0.9; 

                marker.setIcon(icon);

                isVisible = !isVisible; 

            }, interval / 2); 

        }

        // 7. CÁLCULO DE DIFERENCIA DE DÍAS (CRÍTICO)
            function getValidDate(dateValue) {
                if (!dateValue || dateValue === 'N/A' || dateValue === 'En Curso') {
                    return null;
                }
                
                let date;
            
                // Si viene como string ISO de Apps Script, tomamos la fecha y forzamos la medianoche local
                if (typeof dateValue === 'string') {
                    // Tomamos solo la parte YYYY-MM-DD
                    const datePart = dateValue.split('T')[0]; 
                    // Creamos la fecha, que se interpreta como medianoche UTC, luego es ajustada por el navegador
                    date = new Date(datePart); 
                } 
                else if (dateValue instanceof Date) {
                    date = dateValue;
                } else {
                    return null;
                }

                                date.setHours(0, 0, 0, 0); 
                
                    return date;
                }
          // Ahora, ajustamos calculateDaysDifference para que use la función de limpieza
            function calculateDaysDifference(startDateStr, endDateStr) {
                // Usamos la función de limpieza para convertir ambas fechas a medianoche del día.
                const startDate = getValidDate(startDateStr);
                const endDate = getValidDate(endDateStr);
                const oneDay = 24 * 60 * 60 * 1000;
            
                if (!startDate || !endDate || startDate.getTime() > endDate.getTime()) {
                    return 0; 
                }
            
                const diffTime = Math.abs(endDate.getTime() - startDate.getTime());
                
                // El redondeo es crucial para evitar errores de huso horario.
                return Math.round(diffTime / oneDay); 
            }
            //              

        // 9. FUNCIÓN DE LIMPIEZA DEL MAPA HISTÓRICO

        function clearHistoryTracking() {

            // Elimina los marcadores históricos del mapa

            historyMarkers.forEach(marker => marker.setMap(null));

            historyMarkers = [];

            

            // Elimina la polilínea del mapa

            if (polyline) {

                polyline.setMap(null);

                polyline = null;

            }

            

            // Oculta el contenedor si no hay seguimiento

            document.getElementById('history-map').style.display = 'none';

        }



        // 6. LÓGICA DE TRACKING HISTÓRICO

        function plotHistoricalTracking(historyData, materialId) {

            clearHistoryTracking(); 

            document.getElementById('history-map').style.display = 'block'; // <--- CRÍTICO: Hacer visible el mapa histórico

            const pathCoordinates = [];

            const bounds = new google.maps.LatLngBounds();

            const material = allMaterials.find(item => item && item.ID_MATERIAL && item.ID_MATERIAL.toUpperCase() === materialId.toUpperCase());

            

            // La fecha del último punto (posición actual) es la fecha de la última actualización en la hoja

            const lastUpdateDateStr = material.FECHA_ACTUALIZACION; 



            historyData.forEach((point, index) => {

                const position = { lat: parseFloat(point.lat), lng: parseFloat(point.lng) };

                

                pathCoordinates.push(position);

                bounds.extend(position);



                let durationDays = 0;

                let departureStr = point.departure; 

                

                // Si no hay departure, es el punto actual (el último en el array)

                if (!departureStr) {

                    // El último segmento es desde el arribo hasta la fecha de la última actualización del material

                    departureStr = lastUpdateDateStr; 

                }

                

                // Calcular duración

                if (point.arrival && departureStr) {

                    durationDays = calculateDaysDifference(point.arrival, departureStr);

                }

                

                const infoContent = `

                    <div style="font-size: 0.9em;">

                        <strong>Punto Histórico ${index + 1}</strong><br>

                        Arribo: ${point.arrival || 'N/A'}<br>

                        Salida: ${point.departure || 'AÚN EN ESTE PUNTO'}<br>

                        <span style="font-weight: bold; color: ${durationDays > 0 ? 'blue' : 'black'};">Duración: ${durationDays} días</span>

                    </div>

                `;



                // Si es el ÚLTIMO PUNTO (posición actual), no creamos marcador duplicado, ya lo hace el mapa superior.

                if (index === historyData.length - 1) {

                    // Se puede marcar el último punto en el mapa histórico con un icono distinto si se desea

                    // Por ahora, solo se usa para la polilínea.

                    return; 

                }



                // Marcador Histórico (Azul)

                const marker = new google.maps.Marker({

                    position: position,

                    map: historyMap,

                    title: `Histórico Punto ${index + 1}: ${point.arrival}`,

                    icon: {

                        path: google.maps.SymbolPath.CIRCLE,

                        scale: 6,

                        fillColor: '#0000FF',

                        fillOpacity: 0.8,

                        strokeWeight: 1,

                        strokeColor: '#0000CC'

                    }

                });

                

                historyMarkers.push(marker);



                const infoWindow = new google.maps.InfoWindow({ content: infoContent });

                marker.addListener('click', () => { infoWindow.open(historyMap, marker); });

            });



            // Dibuja la polilínea

            polyline = new google.maps.Polyline({

                path: pathCoordinates,

                geodesic: true,

                strokeColor: '#0000FF',

                strokeOpacity: 0.8,

                strokeWeight: 2,

                map: historyMap

            });



            // Ajusta el zoom del mapa histórico

            if (!bounds.isEmpty()) {

                historyMap.fitBounds(bounds);

            }

        }

        

        // 8. LÓGICA DEL CONTADOR DE DÍAS (SUPERPUESTO)

        function updateDayCounter(lastUpdateStr, position) {
            // Aseguramos que tenemos un material activo y una posición
            if (!activeMarkerId) {
                document.getElementById('day-counter-overlay').style.display = 'none';
                return;
            }
        
            const material = allMaterials.find(item => item && item.ID_MATERIAL && item.ID_MATERIAL.toUpperCase() === activeMarkerId.toUpperCase());
            // CRÍTICO: Usamos FECHA_ACTUALIZACION del material, ya que Apps Script la actualiza.
            const arrivalDateStr = material.FECHA_ACTUALIZACION;
            if (!arrivalDateStr || arrivalDateStr === 'N/A') { 
                    document.getElementById('day-counter-overlay').style.display = 'none';
                    return;
                }
            
                const daysElapsed = calculateDaysDifference(arrivalDateStr, new Date()); 
                const counterDiv = document.getElementById('day-counter-overlay');
                
                if (daysElapsed === 'N/A' || daysElapsed <= 0) { // Ahora debe ser daysElapsed <= 0 (si es 5 es > 0)
                    counterDiv.style.display = 'none';
                    return;
                }
                        
            // CRÍTICO: El último punto del historial es la posición actual.
            // La fecha de arribo de ese punto es la fecha de la hoja (que es la última vez que se movió)
                    counterDiv.innerText = `${daysElapsed} días`;
                    counterDiv.style.display = 'block';

            }

            

        function clearActiveMarker() {

            if (activeMarker) {

                activeMarker.setMap(null);

                activeMarker = null;

                activeMarkerId = null;

            }

            if (blinkInterval) {

                clearInterval(blinkInterval);

                blinkInterval = null;

            }

            document.getElementById('material-details').style.display = 'none'; // Oculta la ficha

            document.getElementById('day-counter-overlay').style.display = 'none'; // Oculta el contador

            clearHistoryTracking(); // <--- CRÍTICO: Limpiar también el mapa de historial

            

            // CORRECTED: Reestablecer el mensaje de estado (SOLUCIÓN AL ERROR DE 'INICIANDO')

            if (initialLoad === false) { // Solo si ya cargó datos

                document.getElementById('status-message').innerText = 'Estado: Seguimiento inactivo. Seleccione un material.'; 

            }

        }

        

        // 8. FUNCIÓN DE BUCLE DE ACTUALIZACIÓN

        function startDataRefresh() {

            fetchMaterialData(); 

            setInterval(fetchMaterialData, 5000); 

        }


        // ==========================================================

        // ** FUNCIONES PARA BÚSQUEDA POR DICCIONARIO (MEJORA 2) **

        // ==========================================================



        /**

         * Filtra los materiales basándose en el campo seleccionado y el término de búsqueda.

         * Se dispara con oninput.

         */

        function filterDictionary(searchTerm) {

            const selector = document.getElementById('search-selector');

            const searchField = selector.value;

            const resultsContainer = document.getElementById('dictionary-results');

            const resultsList = document.getElementById('results-list');

            

            if (searchTerm.length < 2) {

                resultsContainer.style.display = 'none';

                return;

            }



            const lowerCaseSearch = searchTerm.toLowerCase();



            const filtered = allMaterials.filter(material => {

                // Aseguramos que el material y el campo existan antes de llamar a toString()

                const value = (material && material[searchField] || '').toString().toLowerCase();

                return value.includes(lowerCaseSearch);

            });



            resultsList.innerHTML = '';



            if (filtered.length > 0) {

                resultsContainer.style.display = 'block';

                

                // Limita los resultados a los primeros 10

                filtered.slice(0, 10).forEach(material => {

                    const li = document.createElement('li');

                    const materialId = material.ID_MATERIAL;

                    // Muestra el valor del campo buscado (ej: el nombre del plano o la descripción)

                    const displayValue = material[searchField] || 'N/A'; 

                    

                    li.innerHTML = `

                        <a href="#" onclick="selectMaterialFromList('${materialId}'); return false;" style="color: #007bff; text-decoration: none;">

                            <strong>ID ${materialId}</strong>

                        </a>: ${displayValue}

                    `;

                    resultsList.appendChild(li);

                });

            } else {

                resultsContainer.style.display = 'none';

            }

        }



        /**

         * Función auxiliar para seleccionar el material desde la lista de diccionario.

         */

        window.selectMaterialFromList = function(materialId) {

            const searchInput = document.getElementById('search-input');

            

            document.getElementById('dictionary-results').style.display = 'none';

            searchInput.value = ''; // Limpiamos la caja de búsqueda (opcional)



            // 1. Mueve el marcador y actualiza el estado.

            updateActiveMarker(materialId);

        }



        /**

         * Muestra la ficha de datos completa en el panel lateral.

         */

        function displayMaterialDetails(materialId) {


            
            const material = allMaterials.find(item => item && item.ID_MATERIAL && item.ID_MATERIAL.toUpperCase() === materialId.toUpperCase());
            const detailsDiv = document.getElementById('material-details');

            if (!material) {
                detailsDiv.style.display = 'none';
                return;
            }

            detailsDiv.style.display = 'block';
            let htmlContent = '<h4>Ficha de Datos del Material Activo</h4>';

            // Iteramos sobre las claves para mostrarlas ordenadamente

            const keysOrder = ['ID_MATERIAL', 'ESTADO', 'DESCRIPCION', 'CANTIDAD', 'OC', 'GUIA', 'PLANO_REF', 'LATITUD', 'LONGITUD', 'FECHA_ACTUALIZACION']; // CRÍTICO: Agregamos FECHA_ACTUALIZACION

            

            keysOrder.forEach(key => {

                let value = material[key] || 'N/A';

                // Excluimos las claves si son nulas o no están en el objeto

                if (value === 'N/A' && !material.hasOwnProperty(key)) return;
                const displayKey = key.replace(/_/g, ' ').toUpperCase(); 


                htmlContent += `

                    <div class="detail-row">
                        <strong>${displayKey}:</strong> ${value}
                    </div>
                `;
            });



            // CRÍTICO: Lógica de visualización del historial en la ficha

            if (material.HISTORY && material.HISTORY.length > 0) {

                htmlContent += `<h4 style="margin-top: 15px;">Historial de Movimientos (${material.HISTORY.length})</h4>`;

  material.HISTORY.forEach((point, index) => {
    
    // Obtener la fecha de arribo del SIGUIENTE punto.
    const nextPoint = material.HISTORY[index + 1];
    
    // El último punto es la POSICIÓN ACTUAL.
    const isCurrentPoint = index === material.HISTORY.length - 1; 
    
    // ----------------------------------------------------------------
    // 1. DETERMINAR FECHA DE SALIDA (Lógica Look-Ahead)
    // ----------------------------------------------------------------
    let departure = 'En Curso';
    let daysElapsed = 0;
    let departureDateStr = '';
    
    if (nextPoint) {
        // SI existe un punto siguiente, su arribo es la salida del punto actual.
        departureDateStr = nextPoint.arrival;
        departure = getValidDate(departureDateStr).toLocaleDateString('es-PE');
        
        // Calcular duración entre el arribo de este punto y el arribo del siguiente
        daysElapsed = calculateDaysDifference(point.arrival, departureDateStr);
        
    } else if (isCurrentPoint) {
        // SI es el último punto, la duración es hasta HOY.
        departure = 'En Curso';
        // Usamos la fecha de la hoja (FECHA_ACTUALIZACION) y HOY para el contador
        daysElapsed = calculateDaysDifference(material.FECHA_ACTUALIZACION, new Date());
    } 
    // Si no es el último punto y no tiene siguiente, algo va mal con los datos, dejará En Curso.


    // ----------------------------------------------------------------
    // 2. CONSTRUCCIÓN FINAL DEL HTML
    // ----------------------------------------------------------------
    
    // Aplicar formato de fecha corta al arribo.
    let arrival = getValidDate(point.arrival).toLocaleDateString('es-PE');

    // Manejar display de Coordenadas (según tu requerimiento)
    let coordsDisplay = '';
    if (point.lat && point.lng) {
        const lat = parseFloat(point.lat).toFixed(4);
        const lng = parseFloat(point.lng).toFixed(4);
        coordsDisplay = `(Posición Actual)`;
    }
    
    // Ajustar el display de duración y estilo (rojo para actual, azul para histórico)
    const color = isCurrentPoint ? 'green' : 'blue';
    const border = isCurrentPoint ? '#ff0000' : '#ccc';
    const durationDisplay = `<span style="font-weight: bold; color: ${color};"> (${daysElapsed} días)</span>`;

    
    htmlContent += `
        <div class="detail-row" style="margin-bottom: 5px; border-left: 3px solid ${border}; padding-left: 5px;">
            <strong>#${index + 1} ${coordsDisplay}</strong>${durationDisplay}: Arribo: ${arrival} / Salida: ${departure}
        </div>
                `;
            });
            }
            
            // Finalmente, actualiza el contenido y cierra la función
            detailsDiv.innerHTML = htmlContent;
        } // <-- CIERRE CORRECTO DE displayMaterialDetails
        
        // ... (el resto de tu código, como loadGoogleMapsScript(), iría después)
        
        // Llama a la carga inicial de Google Maps
        loadGoogleMapsScript();

    </script>



</body>

</html>
